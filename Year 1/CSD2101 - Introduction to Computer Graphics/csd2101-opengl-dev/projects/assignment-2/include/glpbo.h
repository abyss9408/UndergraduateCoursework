/*!
@file       glpbo.h
@author     pghali@digipen.edu
@co-author  parminder.singh@digipen.edu
@co-author	bryanweize.ang@digipen.edu
@date       11/07/2024

This file contains the declaration of structure GLPbo that encapsulates the
functionality required to stream images generated by a 3D graphics pipe 
emulator executed on the CPU for display by the GPU.

See the assignment specs for details ...
*//*__________________________________________________________________________*/

/*                                                                      guard
----------------------------------------------------------------------------- */
#ifndef GLPBO_H
#define GLPBO_H

/*                                                                   includes
----------------------------------------------------------------------------- */
#include <GL/glew.h> // for access to OpenGL API declarations 
#include <glslshader.h> // GLSLShader class definition
#include <glm/glm.hpp>
#include <glm/ext.hpp>
#include <dpml.h>
#include <vector>
#include <array>
#include <iostream>
#include <sstream>
#include <iomanip>

/*  _________________________________________________________________________ */
struct GLPbo
  /*! GLPbo structure to encapsulate 3D graphics pipe emulator which will write
  an image composed of 32-bit RGBA values to PBO, copy the image from PBO to image 
  store of a texture object, and finally use this texture image to render a 
  full-window quad that will display the emulator's output (phew).
  */
{
  // forward declaration
  union Color;

  //-------------- static member function declarations here -----------------
  
  // this is where the emulator does its work of emulating the graphics pipe
  // it generates images using set_pixel to write to the PBO
  static void emulate();
  
  // render quad using the texture image generated by emulate()
  // also prints appropriate information to window's title bar ...
  static void draw_fullwindow_quad();

  // initialization and cleanup stuff ...
  static void init(GLsizei w, GLsizei h);
  static void setup_quad_vao();
  static void setup_shdrpgm();
  static void cleanup();

  // ---------------static data members are declared here ----------------
  
  // Storage requirements common to emulator, PBO and texture object
  static GLsizei width, height; // dimensions of buffers
  // rather than computing these values many times, compute once in
  // GLPbo::init() and then forget ...
  static GLsizei pixel_cnt, byte_cnt; // how many pixels and bytes
  // pointer to PBO's data store - must be set every frame with  
  // the value returned by glMapNamedBuffer()
  static Color *ptr_to_pbo;

  // emulate the depth buffer
  static std::vector<GLfloat> depthBuffer;

  // geometry and material information ...
  static GLuint vaoid;        // with GL 4.5, VBO & EBO are not required
  static GLuint elem_cnt;     // how many indices in element buffer
  static GLuint pboid;        // id for PBO
  static GLuint texid;        // id for texture object
  static GLSLShader shdr_pgm; // object that abstracts away nitty-gritty
                              // details of shader management

// --- here we're trying to emulate GL's functions for clearing colorbuffer ---

  // overloaded functions akin to glClearcolor that set GLPbo::clear_clr
  // with user-supplied parameters ...
  static void set_clear_color(GLPbo::Color);
  static void set_clear_color(GLubyte r, GLubyte g, GLubyte b, GLubyte a = 255);

  // akin to glClear(GL_COLOR_BUFFER_BIT) - uses the pointer ptr_to_pbo
  // to get access to the PBO's data store ...
  static void clear_color_buffer();

  // what value to use for clearing color buffer?
  static Color clear_clr;

  union Color
    /*! glm doesn't have type unsigned char [4] - therefore we declare our
    own type.
    Since Color is such a common type name in graphics applications, make
    sure to encapsulate the name in scope GLPbo!!!
    */
  {
    struct {
      GLubyte r, g, b, a; // a, b, g, r
    };
    GLubyte val[4]; // treat <r,g,b,a> as array of 8-bit unsigned values
    GLuint raw;     // treat <r,g,b,a> as 32-bit unsigned value

    Color(GLubyte re = 0, GLubyte gr = 0, GLubyte bl = 0, GLubyte al = 255) :
      r(re), g(gr), b(bl), a(al) {}
  };

  struct Vertex
  {
      glm::vec2 position;
      glm::vec2 texture;
  };
  
  struct Model
  {
      std::vector<glm::vec3> pos_model;
      std::vector<glm::vec3> pos_world;
      std::vector<glm::vec3> pos_viewport;
      std::vector<glm::vec3> nml;
      std::vector<glm::vec3> nml_xform;
      std::vector<unsigned short> tri;
      std::vector<glm::vec2> tex;
      GLfloat angle_disp{ 0.f };

      enum class RenderMode
      {
          WIREFRAME = 0,
          SHADOW_MAP,
          FACETED,
          SHADED,
          TEXTURED,
          TEXTURED_FACETED,
          TEXTURED_SHADED
      };

      RenderMode render_mode{ RenderMode::WIREFRAME };
  };

  struct PointLight
  {
      glm::vec3 intensity;
      glm::vec3 position;
  };

  struct Texture
  {
      GLint width, height, bytes_per_texel;
      std::vector<GLubyte> texels;
  };

  static std::vector<Model> models;
  static PointLight light_source;
  static Texture ogre_texture;

  static void set_pixel(GLint x, GLint y, Color clr);
  static void set_pixel_depth(GLint x, GLint y, GLfloat depth);

  static void model_to_viewport_xform();

  static void render_linebresenham(GLint px0, GLint py0,
      GLint px1, GLint py1, const Color& draw_clr);

  template <typename PixelFunc>
  static bool render_triangle(glm::vec3 const& p0, glm::vec3 const& p1, glm::vec3 const& p2, PixelFunc&& set_pixel_func);
  
  static bool render_triangle_shadow_map(glm::vec3 const& p0, glm::vec3 const& p1, glm::vec3 const& p2);
  
  static bool render_triangle_faceted(glm::vec3 const& p0, glm::vec3 const& p1, glm::vec3 const& p2, 
      glm::vec3 const& lighting);
 
  static bool render_triangle_smooth(glm::vec3 const& p0, glm::vec3 const& p1, glm::vec3 const& p2, 
      glm::vec3 const& l0, glm::vec3 const& l1, glm::vec3 const& l2);
  
  static bool render_triangle_texture_map(glm::vec3 const& p0, glm::vec3 const& p1, glm::vec3 const& p2, 
      glm::vec2 const& t0, glm::vec2 const& t1, glm::vec2 const& t2);
  
  static bool render_triangle_texture_faceted(glm::vec3 const& p0, glm::vec3 const& p1, glm::vec3 const& p2, 
      glm::vec3 const& lighting, glm::vec2 const& t0, glm::vec2 const& t1, glm::vec2 const& t2);
  
  static bool render_triangle_texture_shaded(glm::vec3 const& p0, glm::vec3 const& p1, glm::vec3 const& p2, 
      glm::vec3 const& l0, glm::vec3 const& l1, glm::vec3 const& l2, 
      glm::vec2 const& t0, glm::vec2 const& t1, glm::vec2 const& t2);
};

#endif /* GLPBO_H */
